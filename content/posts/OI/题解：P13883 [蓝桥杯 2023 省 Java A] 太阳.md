+++
date = '2026-01-10T19:49:51+08:00'
draft = true
title = '题解：P13883 [蓝桥杯 2023 省 Java A] 太阳'
tags: ["OI", "算法"]
categories: ["学习笔记"]
math: true
+++
太阳好闪，拜谢太阳！

感觉我的做法有点复杂了，如果有更优的做法欢迎教我。

考虑纵坐标高的线段可能会遮挡底下的线段，因此我们从高到低排序所有线段后依次考虑所有线段。

考虑一条线段能被照射到，当且仅当太阳到它两个端点之间存在某处不存在线段遮挡。维护每条线段的两端点到太阳和纵轴的直线的斜率的倒数（为啥要维护这东西呢，因为从左往右这东西也是递增的，方便维护，可以看作一个带方向的 $\tan$）。

显然如果区间里存在某个斜率倒数值还没被覆盖到那么这个区间可以被照到。

问题是直接维护小数区间容易有精度误差，不好维护，考虑离散化后上线段树，某个位置为 $0$ 或 $1$ 表示是否被线段覆盖到。

然后支持区间推平和查询是否有还没被覆盖的点即可。查询可以通过维护区间 $\min$ 解决。

一个要注意的点是，要求照射到的面积大于 $0$ 才算被照射到，因此只照射到一个点是不行的。可以通过半开半闭地维护线段树来解决这个问题（这样维护的东西可以看作是两点之间的段，而不再是一个个单独的点了）。

另外，对于每条线段的两个端点在离散化后都有可能扔进线段树，所以线段树要开到八倍空间。

::::info[代码]
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define up(l,r,i) for(int i=(l);(i)<=(r);++i)
#define pb push_back
#define all(x) x.begin(),x.end()

void ios_optimize(){ios::sync_with_stdio(0);cin.tie(0);}
ll ls(ll u){return u<<1;}
ll rs(ll u){return u<<1|1;}

constexpr int N=2e5+9;

ll n,X,Y,ans;

struct seg{
    ll x,y,l;
    friend bool operator <(seg a,seg b){
        return a.y>b.y;
    }
}a[N];

vector<long double> v,p;

int tr[N*4],tag[N*4];

void pushup(int u){
    tr[u]=min(tr[ls(u)],tr[rs(u)]);
}

void build(int u,int l,int r){
    tag[u]=0;tr[u]=0;
    if(l==r) return;
    int mid=(l+r)>>1;
    build(ls(u),l,mid);
    build(rs(u),mid+1,r);
    pushup(u);
}

void pushdown(int u){
    if(tag[u]){
        tag[ls(u)]=tag[rs(u)]=1;
        tr[ls(u)]=tr[rs(u)]=1;
        tag[u]=0;
    }
}

void update(int u,int l,int r,int L,int R){
    if(L<=l&&r<=R){
        tr[u]=1;tag[u]=1;
        return;
    }
    pushdown(u);
    int mid=(l+r)>>1;
    if(L<=mid) update(ls(u),l,mid,L,R);
    if(R>mid) update(rs(u),mid+1,r,L,R);
    pushup(u);
}

bool query(int u,int l,int r,int L,int R){
    if(L<=l&&r<=R) return tr[u];
    pushdown(u);
    int mid=(l+r)>>1;
    bool res=1;
    if(L<=mid)res&=query(ls(u),l,mid,L,R);
    if(R>mid)res&=query(rs(u),mid+1,r,L,R);
    return res;
}

int main()
{
    ios_optimize();
    cin>>n>>X>>Y;
    up(1,n,i){
        cin>>a[i].x>>a[i].y>>a[i].l;
    }
    sort(a+1,a+n+1);
    up(1,n,i){
        v.pb((long double)(a[i].x-X)/(long double)(Y-a[i].y));
        v.pb((long double)(a[i].x+a[i].l-X)/(long double)(Y-a[i].y));
    }
    p=v;sort(all(p));
    p.erase(unique(all(p)),p.end());
    for(auto &x:v)x=lower_bound(all(p),x)-p.begin()+1;
    build(1,1,n*2);
    up(1,n,i){
        int l=v[(i-1)*2],r=v[(i-1)*2+1];
        if(!query(1,1,n*2,l,r-1)){
            ++ans;
            update(1,1,n*2,l,r-1);
        }
    }
    cout<<ans;
	return 0;
}
```
::::